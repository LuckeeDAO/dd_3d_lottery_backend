# DD 3D 彩票智能合约技术文档

## 项目概述

基于 CosmWasm 2.2.2 框架构建的去中心化 3D 彩票智能合约，实现基于区块链高度的三阶段投注系统。

## 核心功能

### 三阶段投注系统

根据区块链高度对 10000 取模后的值，将投注过程分为三个阶段：

1. **承诺阶段 (0-5999)**：用户投注并设置随机数
2. **中奖揭秘阶段 (6000-8999)**：用户揭秘随机数
3. **结算阶段 (9000-9999)**：计算中奖号码并分配奖金

### 投注机制

- 用户转移K个基础代币获得K次幸运数字投注，每个幸运数字可以投注多次（K为任意正整数）
- **重要限制**：单个幸运号码最多只能出现1000次
- **投注限制**：最大投注金额为1,000,000个基础代币
- **数量限制**：幸运数字总数量（投注倍数之和）最大为1,000,000个
- **承诺阶段**：用户设置随机数种子和幸运数字投注列表，计算承诺哈希，只发送哈希值
- **中奖揭秘阶段**：用户发送原始随机数种子和幸运数字投注列表供验证
- **随机数种子**：0-999之间的数字，直接决定最终中奖幸运数字，任何客户端都可以验证，抗合谋
  - **重要**：中奖揭秘阶段提供的所有幸运数字投注倍数之和必须等于承诺阶段转移的代币数量K
  - 如果转移1000个代币，可以投注123号码1000次，或者投注123号码500次+456号码500次，只要总和等于1000即可
- 幸运数字取值范围：0-999
- 系统限制投注金额范围：1,000-1,000,000个基础代币（基础代币的整数倍）
- 允许选择重复的幸运数字（通过重复投注实现）
- **投注机制**：投注金额K必须等于所有幸运数字的投注倍数之和

### 奖金分配

- 当期销售额的 90% 作为奖金池
- 10% 作为软件服务费
- 一等奖：如果用户选择的幸运数字中有几个等于中奖号码，就中奖几次
- 中奖号码是由所有用户设置的随机数种子（0-999之间的数字）直接决定的，任何客户端都可以验证，抗合谋
- 没有二等奖与三等奖，只有一个奖项，就是一等奖
- 如果奖金池子金额大于中奖者数量×800，则每名中奖者固定获得800个基础代币
- 如果奖金池子金额小于中奖者数量×800，则所有中奖者平分奖金池

## 技术架构

### 依赖框架

```toml
[dependencies]
cosmwasm-schema = { version = "2.2.2", default-features = false }
cosmwasm-std = "2.2.2"
cw-storage-plus = "2"
cw2 = "2"
cw-utils = "2.0"
schemars = "0.8"
serde = { version = "1.0", default-features = false, features = ["derive"] }
thiserror = "1.0"
sha2 = "0.10"
dd_algorithms_lib = "0.1.0"  # 去中心化算法库
```

### 项目结构

```
dd_3d_lottery/
├── src/
│   ├── contract.rs         # 合约入口点
│   ├── execute.rs          # 执行消息处理
│   ├── query.rs            # 查询消息处理
│   ├── msg.rs              # 消息定义
│   ├── state.rs            # 状态管理
│   ├── error.rs            # 错误定义
│   ├── phase_manager.rs    # 阶段管理
│   ├── lottery_logic.rs    # 彩票逻辑
│   ├── reward_system.rs    # 奖励系统
│   └── lib.rs              # 库入口
├── tests/                  # 测试文件
├── scripts/                # 部署脚本
├── docs/                   # 项目文档
├── Cargo.toml             # 项目配置
└── README.md              # 项目说明
```

## 数据结构设计

### 核心状态

```rust
// 彩票会话
pub struct LotterySession {
    pub session_id: String,
    pub phase: LotteryPhase,
    pub total_pool: Uint128,
    pub participants: Vec<Participant>,
    pub created_height: u64,
    pub service_fee_rate: Decimal,
}

// 参与者信息
pub struct Participant {
    pub address: Addr,
    pub bet_amount: Uint128,
    pub lucky_numbers: Vec<u16>,
    pub random_seed: Option<String>,
    pub revealed: bool,
    pub commitment_hash: Option<String>,
}

// 彩票阶段
pub enum LotteryPhase {
    Commitment,    // 承诺阶段 (0-5999)
    Reveal,        // 中奖揭秘阶段 (6000-8999)
    Settlement,    // 结算阶段 (9000-9999)
}
```

### 存储映射

```rust
// 当前彩票会话
pub const CURRENT_SESSION: Item<LotterySession> = Item::new("current_session");

// 参与者承诺
pub const COMMITMENTS: Map<&Addr, Commitment> = Map::new("commitments");

// 彩票历史
pub const LOTTERY_HISTORY: Map<u64, LotteryResult> = Map::new("lottery_history");

// 系统配置
pub const CONFIG: Item<Config> = Item::new("config");
```

## 消息接口

### 实例化消息

```json
{
  "admin": "cosmwasm1...",
  "service_fee_rate": "0.1",
  "min_bet_amount": "1000",
  "max_bet_amount": "1000000"
}
```

### 执行消息

```json
{
  "place_bet": {
    "commitment_hash": "a1b2c3d4e5f6..."
  }
}
```

```json
{
  "reveal_random": {
    "lucky_numbers": [123, 456, 789],
    "random_seed": "user_random_string"
  }
}
```

```json
{
  "settle_lottery": {}
}
```

### 查询消息

```json
{
  "get_current_session": {}
}
```

```json
{
  "get_participant_info": {
    "participant": "cosmwasm1..."
  }
}
```

```json
{
  "get_lottery_result": {
    "session_id": "session_123"
  }
}
```

## 核心算法

### 承诺哈希计算

承诺哈希用于在承诺阶段隐藏用户的幸运数字和随机种子，确保公平性：

```rust
pub fn generate_commitment_hash(
    lucky_numbers: &[u16],
    random_seed: &str,
    bet_amount: u128,
) -> String {
    // 使用投注数量而不是幸运数字数量，避免哈希碰撞
    let mut commitment_data = format!("{}|", bet_amount);
    for (i, num) in lucky_numbers.iter().enumerate() {
        if i > 0 {
            commitment_data.push('|');
        }
        commitment_data.push_str(&num.to_string());
    }
    commitment_data.push('|');
    commitment_data.push_str(random_seed);
    
    // 计算SHA256哈希
    let mut hasher = Sha256::new();
    hasher.update(commitment_data.as_bytes());
    format!("{:x}", hasher.finalize())
}
```

**示例**：
- 投注数量：5000
- 幸运数字：[123, 456, 789]
- 随机种子："my_secret_seed_123"
- 承诺数据："5000|123|456|789|my_secret_seed_123"
- 承诺哈希：SHA256("5000|123|456|789|my_secret_seed_123")

### 阶段判断

```rust
pub fn get_current_phase(block_height: u64) -> LotteryPhase {
    let phase_mod = block_height % 10000;
    match phase_mod {
        0..=5999 => LotteryPhase::Commitment,
        6000..=8999 => LotteryPhase::Reveal,
        9000..=9999 => LotteryPhase::Settlement,
        _ => LotteryPhase::Commitment,
    }
}
```

### 中奖号码计算

```rust
use dd_algorithms_lib::get_one_dd_3d_rand_num;

pub fn calculate_winning_number(participants: &[Participant]) -> Result<u16, ContractError> {
    let mut random_values = Vec::new();
    
    // 收集所有参与者的随机数种子
    for participant in participants {
        if let Some(seed) = &participant.random_seed {
            // 将随机种子转换为u128数值
            let seed_value = hash_to_u128(seed);
            random_values.push(seed_value);
        }
    }
    
    if random_values.is_empty() {
        return Err(ContractError::NoParticipants);
    }
    
    // 使用dd_algorithms_lib的去中心化算法计算中奖号码
    let n = random_values.len();
    let k = 1000; // 3D彩票号码范围0-999
    let mut result = 0u128;
    
    get_one_dd_3d_rand_num(&random_values, n, k, &mut result)
        .map_err(|_| ContractError::RandomGenerationFailed)?;
    
    Ok(result as u16)
}
```

### 奖金分配算法

#### 分配规则

本系统采用公平的奖金分配机制，确保所有中奖者获得相同的奖金金额：

**1. 固定奖金分配（优先策略）**
- **触发条件：** 奖金池金额 ≥ 中奖者数量 × 800个基础代币
- **分配方式：** 每名中奖者固定获得800个基础代币
- **优势：** 保证中奖者获得稳定的奖金

**2. 平分奖金分配（兜底策略）**
- **触发条件：** 奖金池金额 < 中奖者数量 × 800个基础代币
- **分配方式：** 所有中奖者平分奖金池
- **计算方式：** 使用整数除法，确保公平分配
- **余数处理：** 余数部分保留在合约资金池中

#### 分配示例

**示例1：固定奖金分配**
- 奖金池：10,000个代币
- 中奖者：5人
- 计算：5 × 800 = 4,000 < 10,000 ✅
- 结果：每人获得800个代币，剩余6,000个代币保留在资金池

**示例2：平分奖金分配**
- 奖金池：1,500个代币
- 中奖者：3人
- 计算：3 × 800 = 2,400 > 1,500 ❌
- 结果：每人获得500个代币（1,500 ÷ 3 = 500），余数0

**示例3：有余数的平分分配**
- 奖金池：1,000个代币
- 中奖者：3人
- 计算：3 × 800 = 2,400 > 1,000 ❌
- 结果：每人获得333个代币（1,000 ÷ 3 = 333），余数1个代币保留在资金池

#### 重要说明

⚠️ **理性投注提醒：** 当资金池不足以分配固定奖金时，系统将采用平分机制。请用户理性投注，了解奖金分配规则，避免因资金池不足导致的奖金减少。

💡 **余数处理：** 平分分配产生的余数将永久保留在合约资金池中，这是确保分配公平性的必要设计，所有中奖者将获得完全相同的奖金金额。

#### 代码实现

```rust
pub fn distribute_rewards(
    winners: &mut Vec<Winner>,
    total_reward_pool: Uint128,
) -> Result<Vec<Winner>, ContractError> {
    // 如果没有中奖者，直接返回空列表
    if winners.is_empty() {
        return Ok(vec![]);
    }
    
    let winner_count = Uint128::from(winners.len() as u128);
    let fixed_reward_per_winner = Uint128::from(800u128); // 固定奖金：800个基础代币
    let total_fixed_rewards = winner_count * fixed_reward_per_winner;
    
    // 计算每个中奖者应得的奖金金额
    let reward_per_winner = if total_reward_pool >= total_fixed_rewards {
        // 情况1：奖金池充足，使用固定奖金分配
        // 每名中奖者获得800个基础代币
        fixed_reward_per_winner
    } else {
        // 情况2：奖金池不足，使用平分分配
        // 所有中奖者平分奖金池，使用整数除法确保公平
        // 余数部分将保留在合约资金池中
        total_reward_pool / winner_count
    };
    
    // 更新所有中奖者的奖金金额
    // 注意：所有中奖者将获得完全相同的奖金金额，确保分配公平性
    for winner in winners.iter_mut() {
        winner.reward_amount = reward_per_winner;
    }
    
    Ok(winners.clone())
}
```

## 安全特性

### 🎲 去中心化随机数安全机制

**核心设计理念**：随机数质量依赖用户输入，这是去中心化随机数系统的重要安全特性。

#### 安全优势

1. **抗单点操控**
   - 任何单一方都无法控制随机数结果
   - 系统管理员、矿工、验证者都无法单独操控结果

2. **集体安全**
   - 只有控制全部参与者才能控制随机数结果
   - 攻击者需要同时控制所有参与者的随机种子

3. **公平透明**
   - 所有参与者共同参与随机数生成过程
   - 随机数生成过程完全透明，结果可验证

4. **可验证性**
   - 任何人都可以验证随机数生成过程
   - 使用公开的去中心化算法，无隐藏逻辑

#### 技术实现

```rust
pub fn calculate_winning_number(participants: &[Participant]) -> Result<u16, ContractError> {
    // 收集所有已揭秘的随机种子
    let mut random_values = Vec::new();
    
    for participant in participants {
        if let Some(seed) = &participant.random_seed {
            if participant.revealed {
                // 将随机种子转换为u128数值
                let seed_value = Self::hash_to_u128(seed);
                random_values.push(seed_value);
            }
        }
    }
    
    // 使用dd_algorithms_lib的去中心化算法计算中奖号码
    let n = random_values.len();
    let k = 1000; // 3D彩票号码范围0-999
    let mut result = 0u128;
    
    get_one_dd_3d_rand_num(&random_values, n, k, &mut result)
        .map_err(|_| ContractError::RandomGenerationFailed)?;
    
    Ok(result as u16)
}
```

#### 安全保证

1. **操控难度**
   - 攻击者需要控制**所有参与者**才能操控随机数
   - 随着参与者数量增加，操控难度呈指数级增长

2. **容错性**
   - 即使部分参与者提供弱随机数，系统仍能保持整体安全性
   - 去中心化算法能够处理部分恶意输入

3. **透明度**
   - 随机数生成过程完全公开
   - 任何人都可以验证结果的正确性

#### 与传统随机数的对比

| 特性 | 传统随机数 | 去中心化随机数 |
|------|------------|----------------|
| 操控风险 | 单点操控风险高 | 需要控制所有参与者 |
| 透明度 | 黑盒操作 | 完全透明可验证 |
| 公平性 | 依赖信任 | 数学保证公平 |
| 安全性 | 中心化风险 | 分布式安全 |

### 防重入保护

```rust
pub const REENTRANCY_LOCK: Item<bool> = Item::new("reentrancy_lock");

pub fn with_reentrancy_protection<F, R>(
    deps: DepsMut,
    f: F,
) -> Result<R, ContractError>
where
    F: FnOnce(DepsMut) -> Result<R, ContractError>,
{
    if REENTRANCY_LOCK.load(deps.storage)? {
        return Err(ContractError::ReentrancyDetected);
    }
    
    REENTRANCY_LOCK.save(deps.storage, &true)?;
    let result = f(deps);
    REENTRANCY_LOCK.save(deps.storage, &false)?;
    
    result
}
```

### 访问控制

```rust
pub fn assert_admin(deps: Deps, sender: &Addr) -> Result<(), ContractError> {
    let config = CONFIG.load(deps.storage)?;
    if sender != &config.admin {
        return Err(ContractError::Unauthorized);
    }
    Ok(())
}
```

### 输入验证

```rust
pub fn validate_lucky_numbers(numbers: &[u16]) -> Result<(), ContractError> {
    if numbers.len() != 3 {
        return Err(ContractError::InvalidLuckyNumbers);
    }
    
    for &number in numbers {
        if number > 999 {
            return Err(ContractError::InvalidLuckyNumbers);
        }
    }
    
    Ok(())
}
```

## 测试策略

### 单元测试

- 阶段判断逻辑测试
- 中奖号码计算测试
- 奖金分配算法测试
- 输入验证测试

### 集成测试

- 完整投注流程测试
- 多用户并发测试
- 边界条件测试
- 错误处理测试

### 性能测试

- 大量参与者压力测试
- Gas 消耗优化测试
- 存储效率测试

## 部署指南

### 环境要求

- Rust 1.70+
- CosmWasm CLI (wasmd)
- cosmwasm-opt (可选)

### 构建步骤

```bash
# 构建合约
cargo build --release --target wasm32-unknown-unknown

# 优化 WASM
cosmwasm-opt target/wasm32-unknown-unknown/release/dd_3d_lottery.wasm \
  -o target/wasm32-unknown-unknown/release/dd_3d_lottery_optimized.wasm
```

### 部署命令

```bash
# 上传合约
wasmd tx wasm store target/wasm32-unknown-unknown/release/dd_3d_lottery.wasm \
  --from <your-key> \
  --gas auto \
  --gas-adjustment 1.3 \
  --chain-id <chain-id> \
  --node <rpc-url> \
  --yes

# 实例化合约
wasmd tx wasm instantiate <code-id> '{"admin":"<admin-address>",...}' \
  --from <your-key> \
  --admin <admin-address> \
  --label "DD 3D Lottery" \
  --chain-id <chain-id> \
  --node <rpc-url> \
  --yes
```

## 监控和维护

### 关键指标

- 投注参与率
- 奖金分配效率
- Gas 消耗统计
- 错误率监控

### 维护操作

- 定期检查合约状态
- 监控异常交易
- 更新系统参数
- 处理用户投诉

## 风险控制

### 技术风险

- 智能合约漏洞
- 网络拥堵影响
- 随机数生成安全

### 业务风险

- 投注金额限制
- 中奖概率控制
- 资金安全保护

### 应对措施

- 代码审计
- 多重签名
- 紧急暂停机制
- 资金保险

## 未来规划

### 功能扩展

- 多期彩票支持
- NFT 奖品集成
- 跨链投注
- 移动端适配

### 技术优化

- 性能提升
- Gas 优化
- 存储压缩
- 查询优化

---

**DD 3D 彩票智能合约** - 构建公平透明的去中心化彩票系统 🎲

